# 编译器设计

## 文法解读

```c
// 单目运算符 UnartOp
+
-
! // 只在条件表达式中出现


// 编译单元
// 常量/变量声明，可以不赋值，可以用逗号分隔多个
const int a = 10, d;
int b = 5, c;
// 函数声明

```

- 源代码中不会出现单引号，且双引号也一定是成对出现来表示字符串
- 单行注释有二种特殊情况：单套多`//*`，双引号套注释。多套单的情况(`/*//*`)可以按照多行注释处理，不用特判
- 由于前面去掉了单套多的情况，多行注释的特殊情况只有塞在双引号里
- 一行的结尾如果不是注释，结尾字符就只可能是`;, {, }`，所以判断字符串`"`等不需要遍历到最后一个位置。**在合法的情况下**
- 多行注释末尾`*/`后面的内容是有效的，但要先判断后面是否真的有内容
- 还要考虑多行注释实际上在一行内的情况
- 多行注释还是拼成一个大字符串处理好办
- 多行注释的右边一定是匹配多行注释的，即使有`"*/"`，也认为多行注释结束了

- 搞一个状态机，分成多个小部分，动态处理
- 最好是按行分，每行一个 token 的 ArrayList`<String>`，这样可以保证行号和信息对应，方便报错

## 词法分析

- 搞几个小函数，一个大函数，大函数负责分类，小函数具体处理
    - 字母、下划线开头
        - 直到获取的结果不是字母、下划线或者**数字**时就停止
    - 数字开头
        - 直到获取的结果不是数字就停止
    - 双引号开头
        - 获取到下一个双引号
    - 其他符号开头（要进行贪心匹配）

最终会返回一个`ArrayList<Token>`，可以通过`getTokens()`获取。
`Iter`用来遍历`Tokens`
一个`token`中有`String val`, `String type`, `int lineNum`

## 语法分析

- 每个语法成分
- 在还未进行到错误处理时，先用`assert`来进行错误的管理
- 进行分支判断时尽量用`preview()`，而不是`next()`
- 要在每个有实际意义的`parseXxx()`函数开始时调用`iter.next()`
- 每个`parseXxx()`函数都不要多读，否则要用`back()`回退
- 通过后序遍历输出语法结构
- 对于自己改了语法结构的东西(比如`AddExp, MulExp`)，要调整后序遍历为符合题目中文法的情况，**或者在构建时就按照合法的情况来做**

## 错误处理

- 形如`>==`

## 提醒

- 注意行号是从 0 开始还是从 1 开始
- 尽量保证除了构造方法以外的其他方法都是纯函数，因为作为构造方法传入的参数在外面可能还是要用的，而构造方法通常只是浅克隆复制了引用，这样一改对象内部的成分，外面的对象也会变
- 考虑使用`\t`作为分隔多个单词的情况
- 了解一下自底向上的分析方法，从而搞定语法分析
