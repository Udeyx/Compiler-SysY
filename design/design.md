# 编译器设计

## 文法解读

```c
// 单目运算符 UnartOp
+
-
! // 只在条件表达式中出现


// 编译单元
// 常量/变量声明，可以不赋值，可以用逗号分隔多个
const int a = 10, d;
int b = 5, c;
// 函数声明

```

- 源代码中不会出现单引号，且双引号也一定是成对出现来表示字符串
- 单行注释有二种特殊情况：单套多`//*`，双引号套注释。多套单的情况(`/*//*`)可以按照多行注释处理，不用特判
- 由于前面去掉了单套多的情况，多行注释的特殊情况只有塞在双引号里
- 一行的结尾如果不是注释，结尾字符就只可能是`;, {, }`，所以判断字符串`"`等不需要遍历到最后一个位置。**在合法的情况下**
- 多行注释末尾`*/`后面的内容是有效的，但要先判断后面是否真的有内容
- 还要考虑多行注释实际上在一行内的情况
- 多行注释还是拼成一个大字符串处理好办
- 多行注释的右边一定是匹配多行注释的，即使有`"*/"`，也认为多行注释结束了

- 搞一个状态机，分成多个小部分，动态处理
- 最好是按行分，每行一个 token 的 ArrayList`<String>`，这样可以保证行号和信息对应，方便报错

## 词法分析

- 搞几个小函数，一个大函数，大函数负责分类，小函数具体处理
    - 字母、下划线开头
        - 直到获取的结果不是字母、下划线或者**数字**时就停止
    - 数字开头
        - 直到获取的结果不是数字就停止
    - 双引号开头
        - 获取到下一个双引号
    - 其他符号开头（要进行贪心匹配）

最终会返回一个`ArrayList<Token>`，可以通过`getTokens()`获取。
`Iter`用来遍历`Tokens`
一个`token`中有`String val`, `String type`, `int lineNum`

## 语法分析

- 每个语法成分
- 在还未进行到错误处理时，先用`assert`来进行错误的管理
- 进行分支判断时尽量用`preview()`，而不是`next()`
- 要在每个有实际意义的`parseXxx()`函数开始时调用`iter.next()`
- 每个`parseXxx()`函数都不要多读，否则要用`back()`回退
- 通过后序遍历输出语法结构
- 对于自己改了语法结构的东西(比如`AddExp, MulExp`)，要调整后序遍历为符合题目中文法的情况，**或者在构建时就按照合法的情况来做**

## 错误处理

| 错误类型/类别码                     | 处理阶段  | 处理方式                                                  |
| ----------------------------------- | --------- | --------------------------------------------------------- |
| 非法符号 a                          | 词法      | 每读入一个完整的 FormatString 就进行检验                  |
| 名字重定义 b                        | 语义      | 使用`Node.check()`检查，加入新变量/函数时先遍历栈顶符号表 |
| 未定义的名字 c                      | 语义      | `Node.check()`，得仔细想                                  |
| 参数个数不匹配                      | 语义      | `Node.check()`，                                          |
| 参数类型不匹配                      | 语义      | `Node.check()`                                            |
| 无返回值的函数<br>写了不对的 return | 语义      | `Node.check()`                                            |
| 有返回值的函数缺少 return           | 语义      | `Node.check()`                                            |
| 改变了常量的值                      | 语义      | `Node.check()`                                            |
| 缺分号                              | 语法      | 手动检测并补上分号                                        |
| 缺右小括号                          | 语法      | 手动检测并补上小括号                                      |
| 缺右中括号                          | 语法      | 同上                                                      |
| `printf`参数不匹配                  | 语义/语法 | 直接特判/`Node.check()`                                   |
| 在非循环中用了`break`和`continue`   | 语义      | `Node.check()`                                            |

- 使用栈式符号表来处理
- 栈式符号表的进出栈是以表为单位的，每次进出都是整个进，整个出

**TODO**

1. 先处理 FormatString 的问题，在`printf`有关的地方加特判，此时直接报错。
2. 处理缺分号、小中括号的情况，在语法部分处理，此时直接报错。
3. 处理语义错误的情况
    1. 首先分清那些语法单元会开启一个新的作用域
    2. 在解析到语法单元时，先申请一个符号表加入栈，确保用正确的表处理当前符号
    3. 要创建一个符号表管理类，用来获取当前的信息
4. 有可能语义错误在语法错误之前发生，这时语法部分直接报错就会出现问题。所以可以建`Checker`类，在其中存所有的错误信息，并在语法分析和错误检查之后按照出现的行数进行重新排序，然后再输出。
5. 符号表表项应该分为变量(包括常量)和函数
6. 符号表的表项是在`check`的过程中生成的
7. 在错误处理和中间代码生成的地方其实可以用同一个符号表栈，因为如果能通过`check`，则栈内一切应该都回到初始状态了。

## 提醒

- 注意行号是从 0 开始还是从 1 开始
- 尽量保证除了构造方法以外的其他方法都是纯函数，因为作为构造方法传入的参数在外面可能还是要用的，而构造方法通常只是浅克隆复制了引用，这样一改对象内部的成分，外面的对象也会变
- 考虑使用`\t`作为分隔多个单词的情况
- 了解一下自底向上的分析方法，从而搞定语法分析
