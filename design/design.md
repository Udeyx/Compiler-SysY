# 编译器设计

## 文法解读

```c
// 单目运算符 UnartOp
+
-
! // 只在条件表达式中出现


// 编译单元
// 常量/变量声明，可以不赋值，可以用逗号分隔多个
const int a = 10, d;
int b = 5, c;
// 函数声明

```

- 源代码中不会出现单引号，且双引号也一定是成对出现来表示字符串
- 单行注释有二种特殊情况：单套多`//*`，双引号套注释。多套单的情况(`/*//*`)可以按照多行注释处理，不用特判
- 由于前面去掉了单套多的情况，多行注释的特殊情况只有塞在双引号里
- 一行的结尾如果不是注释，结尾字符就只可能是`;, {, }`，所以判断字符串`"`等不需要遍历到最后一个位置。**在合法的情况下**
- 多行注释末尾`*/`后面的内容是有效的，但要先判断后面是否真的有内容
- 还要考虑多行注释实际上在一行内的情况
- 多行注释还是拼成一个大字符串处理好办
- 多行注释的右边一定是匹配多行注释的，即使有`"*/"`，也认为多行注释结束了

- 搞一个状态机，分成多个小部分，动态处理
- 最好是按行分，每行一个 token 的 ArrayList`<String>`，这样可以保证行号和信息对应，方便报错

## 词法分析

- 搞几个小函数，一个大函数，大函数负责分类，小函数具体处理
    - 字母、下划线开头
        - 直到获取的结果不是字母、下划线或者**数字**时就停止
    - 数字开头
        - 直到获取的结果不是数字就停止
    - 双引号开头
        - 获取到下一个双引号
    - 其他符号开头（要进行贪心匹配）

最终会返回一个`ArrayList<Token>`，可以通过`getTokens()`获取。
`Iter`用来遍历`Tokens`
一个`token`中有`String val`, `String type`, `int lineNum`

## 语法分析

- 每个语法成分
- 在还未进行到错误处理时，先用`assert`来进行错误的管理
- 进行分支判断时尽量用`preview()`，而不是`next()`
- 要在每个有实际意义的`parseXxx()`函数开始时调用`iter.next()`
- 每个`parseXxx()`函数都不要多读，否则要用`back()`回退
- 通过后序遍历输出语法结构
- 对于自己改了语法结构的东西(比如`AddExp, MulExp`)，要调整后序遍历为符合题目中文法的情况，**或者在构建时就按照合法的情况来做**

## 错误处理

**错误重点！！！**

- 在函数声明重名的时候，还要开启新作用域吗
- `int`函数有`return`，但是不返回`int`算错吗？
- 刚刚正在对着 tetsfile2 和 3 处理右大括号的问题，以及声明自定义函数失败时的符号表和`Manager`中全局变量的问题

**搞定后检查一遍所有的行数是不是对了**
**检查一遍作用域的开启时间是否合理**
**最后要检查一下 ErrorType 枚举类有没有失误**
**重名函数与不重名函数处理上唯二的区别在于时候要添加参数（给重名函数添加参数会直接 cast error）以及要不要报 B**
**idDefined 遍历到了被弹出的符号表！！！**
**在进行实参类型检查时，没有根据方括号降维！！！**
**for 多层**
**在回溯时，多进行了一次报错**
**函数末尾的 return 语句，一定真的在末尾！！！**

```c
void d() {

}
int main() {
	int d = 1;
	d();
	return 0;
}
// 这个不算错
```

```c
int g() {
}
int main() {
    f();
    g = 1;
}
// 这个算不算错？
```

- [x] a: 在`Terminator`中，如果`val`的`TokenType`为`STRCON`，则进行检查
- [ ] b: 查看`Manager`栈顶的符号表（即当前作用域）中有没有同名变量
- [ ]

- 使用栈式符号表来处理
- 栈式符号表的进出栈是以表为单位的，每次进出都是整个进，整个出
- 把错误信息存在 node 中，由于使用 Terminator 对终结符进行了包装，所有错误最终都会有一个单独的 Terminator（如果是语义错误则是其他节点） 来表示
- 一个`Node`中是有可能有多个同级错误产生的，比如 UnaryExp 中，函数参数和返回值同时出问题。因此，每一个 Node 里面最好有一个 ArrayList 存各种错误，然后检查的时候，按照顺序检查。
- stmt 中缺少分号的有这几种：普通赋值、exp;、break、continue、return、getint、printf、**for 条件中的分号**
- 要考虑分号对 stmt 中几个东西本来解析的影响！！！小括号也会影响！！！
- `Exp`的 first 集是: `{ LPARENT, IDENFR, INTCNT, +, -, ! }`
- `UnaryExp`的 first 集与`Exp`的 first 集相同
- `FuncRParams`的 first 集与`Exp`相同
- `FuncFParams`的 first 集里只有`int`
- `stmt`中缺少小括号的有这几种：`if`, `for`, `getint`, `printf`
- `ForStmt`的 first 集里只有`IDENTR`
- 函数形参的问题要考虑好。这需要在合适的位置存储函数形参的信息，这一方面保证错误处理中重复定义和未定义能正常检测，另一方面保证中间代码生成正确进行。这里有个难点是，形参是在还没遇到大括号时来的，就导致不能机械的用大括号来申请作用域，而应该在碰到函数定义时就申请作用域，并在`block`中加入判断，如果当前在函数中的话，就不再申请新的作用域。此外，在函数声明结束时的 check 中，应该把 curFunc 置为 null，方便`block`的判断。
- 在 FuncDef，设置函数的类型。并继续处理 f 错误。
- 设置一个全局变量存放函数右大括号，在 block 里面判断并设置一下。要注意这个的报错位置！！！这个应该在内部报错结束后，才进行报错。

**TODO**

- [x] 添加`Printer`类，并在词法和语法上检查正确性
- [x] 把符号表内部的符号换成`HashMap<String, Symbol>`来存储
- [ ] 给一些多种可能的文法，增加内部枚举类，判断类型
- [ ] 查找符号时，要从栈顶的符号表开始找！！！
- [ ] 之前的类型判断完全错了，没有考虑数组取值时应该降维！！！
- [ ] 变量声明时数组的维数算错了！！！应该除以 3，错除以成 2 了！！！
- [ ] 没考虑没有 return 的情况！！！
- [ ] 去掉对 for 循环的错误处理
- [ ] 手搓数据进行测试
- [x] 考虑建立一个错误表，使用行号排序

13. 处理语义错误的情况
    1. 首先分清那些语法单元会开启一个新的作用域
    2. 在解析到语法单元时，先申请一个符号表加入栈，确保用正确的表处理当前符号
    3. 要创建一个符号表管理类，用来获取当前的信息
14. 有可能语义错误在语法错误之前发生，这时语法部分直接报错就会出现问题。所以可以建`Checker`类，在其中存所有的错误信息，并在语法分析和错误检查之后按照出现的行数进行重新排序，然后再输出。
15. 符号表表项应该分为变量(包括常量)和函数
16. 符号表的表项是在`check`的过程中生成的
17. 在错误处理和中间代码生成的地方其实可以用同一个符号表栈，因为如果能通过`check`，则栈内一切应该都回到初始状态了。
18. 考虑一行中出现多个相同报错的情况！！！
19. 建立一个符号表来处理语义错误，只有变量和函数在声明时才需要加入符号表。
20. 随 block 出现而申请作用域。
21. 在代码生成和建符号表的过程中各建一次符号表。在变量声明的 check 中，如果没有错误，就把符号加入符号表。
22. 在 block 的 check 中，开局就建立符号表，在 check 结束时，弹出当前符号表。
23. 在 compunit 开始时，也申请一个作用域，作为存放全局变量的地方。
24. 在 manager 中记录当前循环深度、在哪个函数的调用中，在 FuncDef 中设置该函数定义的函数名。
25. 考虑函数反复定义时对参数的处理：在非正常定义时，设置 curfunction 为 null。之后在解析 funcrparam 时，如果 curfunc 为 null，那就只在当前符号表里添加东西，否则还在修改函数对应的表项，为它增加信息。
26. 返回值的问题要仔细考虑

## 中间代码生成

## 提醒

- 尽量保证除了构造方法以外的其他方法都是纯函数，因为作为构造方法传入的参数在外面可能还是要用的，而构造方法通常只是浅克隆复制了引用，这样一改对象内部的成分，外面的对象也会变
