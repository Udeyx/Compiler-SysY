# 编译器设计

## 文法解读

```c
// 单目运算符 UnartOp
+
-
! // 只在条件表达式中出现


// 编译单元
// 常量/变量声明，可以不赋值，可以用逗号分隔多个
const int a = 10, d;
int b = 5, c;
// 函数声明

```

- 源代码中不会出现单引号，且双引号也一定是成对出现来表示字符串
- 单行注释有二种特殊情况：单套多`//*`，双引号套注释。多套单的情况(`/*//*`)可以按照多行注释处理，不用特判
- 由于前面去掉了单套多的情况，多行注释的特殊情况只有塞在双引号里
- 一行的结尾如果不是注释，结尾字符就只可能是`;, {, }`，所以判断字符串`"`等不需要遍历到最后一个位置。**在合法的情况下**
- 多行注释末尾`*/`后面的内容是有效的，但要先判断后面是否真的有内容
- 还要考虑多行注释实际上在一行内的情况
- 多行注释还是拼成一个大字符串处理好办
- 多行注释的右边一定是匹配多行注释的，即使有`"*/"`，也认为多行注释结束了

- 搞一个状态机，分成多个小部分，动态处理
- 最好是按行分，每行一个 token 的 ArrayList`<String>`，这样可以保证行号和信息对应，方便报错

## 词法分析

- 搞几个小函数，一个大函数，大函数负责分类，小函数具体处理
    - 字母、下划线开头
        - 直到获取的结果不是字母、下划线或者**数字**时就停止
    - 数字开头
        - 直到获取的结果不是数字就停止
    - 双引号开头
        - 获取到下一个双引号
    - 其他符号开头（要进行贪心匹配）

最终会返回一个`ArrayList<Token>`，可以通过`getTokens()`获取。
`Iter`用来遍历`Tokens`
一个`token`中有`String val`, `String type`, `int lineNum`

## 语法分析

- 每个语法成分
- 在还未进行到错误处理时，先用`assert`来进行错误的管理
- 进行分支判断时尽量用`preview()`，而不是`next()`
- 要在每个有实际意义的`parseXxx()`函数开始时调用`iter.next()`
- 每个`parseXxx()`函数都不要多读，否则要用`back()`回退
- 通过后序遍历输出语法结构
- 对于自己改了语法结构的东西(比如`AddExp, MulExp`)，要调整后序遍历为符合题目中文法的情况，**或者在构建时就按照合法的情况来做**

## 错误处理

**错误重点！！！**

- 在函数声明重名的时候，还要开启新作用域吗
- `int`函数有`return`，但是不返回`int`算错吗？
- 刚刚正在对着 tetsfile2 和 3 处理右大括号的问题，以及声明自定义函数失败时的符号表和`Manager`中全局变量的问题

**搞定后检查一遍所有的行数是不是对了**
**检查一遍作用域的开启时间是否合理**
**最后要检查一下 ErrorType 枚举类有没有失误**
**重名函数与不重名函数处理上唯二的区别在于时候要添加参数（给重名函数添加参数会直接 cast error）以及要不要报 B**
**idDefined 遍历到了被弹出的符号表！！！**
**在进行实参类型检查时，没有根据方括号降维！！！**
**for 多层**
**在回溯时，多进行了一次报错**
**函数末尾的 return 语句，一定真的在末尾！！！**

```c
void d() {

}
int main() {
	int d = 1;
	d();
	return 0;
}
// 这个不算错
```

```c
int g() {
}
int main() {
    f();
    g = 1;
}
// 这个算不算错？
```

- [x] a: 在`Terminator`中，如果`val`的`TokenType`为`STRCON`，则进行检查
- [ ] b: 查看`Manager`栈顶的符号表（即当前作用域）中有没有同名变量
- [ ]

- 使用栈式符号表来处理
- 栈式符号表的进出栈是以表为单位的，每次进出都是整个进，整个出
- 把错误信息存在 node 中，由于使用 Terminator 对终结符进行了包装，所有错误最终都会有一个单独的 Terminator（如果是语义错误则是其他节点） 来表示
- 一个`Node`中是有可能有多个同级错误产生的，比如 UnaryExp 中，函数参数和返回值同时出问题。因此，每一个 Node 里面最好有一个 ArrayList 存各种错误，然后检查的时候，按照顺序检查。
- stmt 中缺少分号的有这几种：普通赋值、exp;、break、continue、return、getint、printf、**for 条件中的分号**
- 要考虑分号对 stmt 中几个东西本来解析的影响！！！小括号也会影响！！！
- `Exp`的 first 集是: `{ LPARENT, IDENFR, INTCNT, +, -, ! }`
- `UnaryExp`的 first 集与`Exp`的 first 集相同
- `FuncRParams`的 first 集与`Exp`相同
- `FuncFParams`的 first 集里只有`int`
- `stmt`中缺少小括号的有这几种：`if`, `for`, `getint`, `printf`
- `ForStmt`的 first 集里只有`IDENTR`
- 函数形参的问题要考虑好。这需要在合适的位置存储函数形参的信息，这一方面保证错误处理中重复定义和未定义能正常检测，另一方面保证中间代码生成正确进行。这里有个难点是，形参是在还没遇到大括号时来的，就导致不能机械的用大括号来申请作用域，而应该在碰到函数定义时就申请作用域，并在`block`中加入判断，如果当前在函数中的话，就不再申请新的作用域。此外，在函数声明结束时的 check 中，应该把 curFunc 置为 null，方便`block`的判断。
- 在 FuncDef，设置函数的类型。并继续处理 f 错误。
- 设置一个全局变量存放函数右大括号，在 block 里面判断并设置一下。要注意这个的报错位置！！！这个应该在内部报错结束后，才进行报错。

**TODO**

- [x] 添加`Printer`类，并在词法和语法上检查正确性
- [x] 把符号表内部的符号换成`HashMap<String, Symbol>`来存储
- [ ] 给一些多种可能的文法，增加内部枚举类，判断类型
- [ ] 查找符号时，要从栈顶的符号表开始找！！！
- [ ] 之前的类型判断完全错了，没有考虑数组取值时应该降维！！！
- [ ] 变量声明时数组的维数算错了！！！应该除以 3，错除以成 2 了！！！
- [ ] 没考虑没有 return 的情况！！！
- [ ] 去掉对 for 循环的错误处理
- [ ] 手搓数据进行测试
- [x] 考虑建立一个错误表，使用行号排序

13. 处理语义错误的情况
    1. 首先分清那些语法单元会开启一个新的作用域
    2. 在解析到语法单元时，先申请一个符号表加入栈，确保用正确的表处理当前符号
    3. 要创建一个符号表管理类，用来获取当前的信息
14. 有可能语义错误在语法错误之前发生，这时语法部分直接报错就会出现问题。所以可以建`Checker`类，在其中存所有的错误信息，并在语法分析和错误检查之后按照出现的行数进行重新排序，然后再输出。
15. 符号表表项应该分为变量(包括常量)和函数
16. 符号表的表项是在`check`的过程中生成的
17. 在错误处理和中间代码生成的地方其实可以用同一个符号表栈，因为如果能通过`check`，则栈内一切应该都回到初始状态了。
18. 考虑一行中出现多个相同报错的情况！！！
19. 建立一个符号表来处理语义错误，只有变量和函数在声明时才需要加入符号表。
20. 随 block 出现而申请作用域。
21. 在代码生成和建符号表的过程中各建一次符号表。在变量声明的 check 中，如果没有错误，就把符号加入符号表。
22. 在 block 的 check 中，开局就建立符号表，在 check 结束时，弹出当前符号表。
23. 在 compunit 开始时，也申请一个作用域，作为存放全局变量的地方。
24. 在 manager 中记录当前循环深度、在哪个函数的调用中，在 FuncDef 中设置该函数定义的函数名。
25. 考虑函数反复定义时对参数的处理：在非正常定义时，设置 curfunction 为 null。之后在解析 funcrparam 时，如果 curfunc 为 null，那就只在当前符号表里添加东西，否则还在修改函数对应的表项，为它增加信息。
26. 返回值的问题要仔细考虑

## 中间代码生成

### LLVM 核心类层次结构

[原文链接](https://www.llvm.org/docs/ProgrammersManual.html#the-core-llvm-class-hierarchy-reference)

#### Type 类及其衍生类

- Type 不能直接实例化，只能通过子类实例化
- 继承了 Type 的基本类有 IntegerType, ArrayType, FunctionType 等
- 每个 Type 对象应该是单例的，因此可以用枚举类
- LLVM 自带一些和 Type 有关的方法：`isIntegerTy`, `isFloatingPointTy`。代表 is ... type

#### Module 类

- 代表了一个被编译文件的顶层结构（对应咱们的 CompUnit），记录一系列的 Function, GlobalVariables 以及**一个 SymbolTable**
- 具有`insertGlobalVariable`, `getSymbolTable`等方法

#### Value 类

- LLVM 中最重要的类
    - 代表了一个**有类型**的值
    - 在各种指令中被当作操作数使用
- 这些都是 Value：Constant, Argument, Function, Instruction
- 一个 Value 会在一个 LLVM 表示中被使用多次。为了维护 Value 和使用者的关系，Value 中维护了一个 User 列表，保存使用它的使用者的信息
- Value 可以有名字，但不是必须的
- 在 LLVM 中，一个 ssa 变量和产生该变量的

#### User 类

- 代表了 llvm 图的结点
- 是 Value 的子类

**TODO**
从简单的开始，逐步生成。`buildIR()`中要先填符号表再生成对应的 llvm 对象
**尽量把维护符号表的任务交给 irBuilder**
**注意，现在一些代码生成的地方其实用到了错误处理维护的类内成员，比如 funcSymbol**
**可以在代码生成中继续用以前的方式维护符号表，并继续用以前的符号**
注意符号表里的维数要慎用，因为llvm系列对象中最高只有1维数组
llvm 的变量是 ssa 的，符号表中存的名称肯定是原来的名称，这样方便查找。但自己在生成的过程中，就必须给每个 Value 分配符合 ssa 的名字

1. 全局变量（变量/常量）
    1. 确定变量的类型（IntegerType 或者是一维数组）
    2. 在所有 exp 中实现 evaluate 方法
    3. 搞一下 global variable 的 toString 方法
    4. 必须要用 zeroinitializer，来初始化一个没有被赋初值的数组，否则
    5. 以后可以把 global variable 中的 initVal 改成 Number，应对以后可能出现 double 类型数据的情况
2. 局部变量及指令
    1. 先把所有要用的指令都给声明了
    2. 把指令在 irbuilder 中的方法看懂
    3. 函数还是得管，不过就目前来说，每个函数只有几个基本块，不用做数据流分析
3. 函数
    1. 在 irbuilder 中写 buildFunction
        1. 维护符号表
        2. 维护 Module 的 Function 列表
        3. 维护 curFunction
        4. 新建一个 basicblock，因为一个函数开头第一个语句一定会开启一个新的基本块
        5. 在 buildFunction 的过程中或许不用把 basicblock 作为参数传进去，而应该设置一个 curFunction，然后在 buildBasicBlock 时，再把东西传到这个函数里面。Argument 也可以这样，没必要在建 Function 的时候全部算好，而且在添加 argument 的时候还得。
            1. 形参的类型是 I32 或者指针，由于之前就把数组拍扁了，这里只认为有一重指针
            2. 如果参数是整数类型，就需要预先用 alloc 创建好指针，以满足 ssa 要求。其实是在开始后就用 alloca 为所有 int 类型变量都设置一个替代品。这也就要求，函数里面的东西使用形参的时候，如果碰到不能直接使用的形参，要用 alloca 出来的变量，一种可行的实现方法是在维护符号表时，变量名就是正常输入的，但 Value 的 name 要视情况而变。在输出为 llvm ir 的时候，函数头都是直接按照占位符的顺序输出，但后面具体使用参数时，要按照符号表的输出。
        6. 传参涉及到参数是数组的情况，要设置好 PointerType
    2. 在 FuncDef 中
        1. 维护 FunctionType
        2. 维护 Arguments
        3. 计算 Argument 和 FunctionType 的时候难免要用到一些指令的东西？那时可能得先解决那些。
        4. 调用 enterFunction，来确保符号表正确
        5. 要为没有 return 语句的函数补上 return 语句，因为 llvm 是必须要有 return 的

### 问题

1. 全局变量是用的哪种 llvm 结构，哪种 type。等号右边的东西又是如何计算的？
   将高维数组干成一维数组！！！也就是说永远只有一维数组！因此全局变量的类型只能是 I32 或者一维数组
   写一个 evaluate 方法来计算东西的值**刚开始的时候，可以默认全部不含变量，但后面就可能用到变量**
   **记得填符号表(这个在 buildGlobalVariable 里面填了！！！)**

2. 函数类里面存什么，函数类型要记录什么，如何数据流分析
   函数中记录参数(Value/Argument)、FunctionType，而 FunctionType 中记录参数类型和返回值类型

3. 数组数据是如何处理的？ArrayType 具体是怎样？数组本身算是什么？Value？

4. Use 和 User 到底在哪用了，怎么维护的？

5. 数据流分析到底是怎么做的？

6. 局部变量对应哪种 llvm 类？Value? allocainstr, 又是哪种 type

7. 有哪些用到的 instr?

### Tips

- 别一步到 ssa ir，先使用访存指令来简化，之后再 memtoreg
- GlobalValue 存的是全局变量、全局常量和函数的地址，这些地址显然是不变的，因此 GlobalValue 继承了 Constant

## 提醒

- 尽量保证除了构造方法以外的其他方法都是纯函数，因为作为构造方法传入的参数在外面可能还是要用的，而构造方法通常只是浅克隆复制了引用，这样一改对象内部的成分，外面的对象也会变
